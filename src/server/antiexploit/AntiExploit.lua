local antiExploit = {
	running = false
}

local services = {
	players = game:GetService("Players"),
	run = game:GetService("RunService")
}

local whitelist = require(script.Parent.assets.utils.Whitelist)

local assets = script.Parent.assets
local detections = assets.detections
local utils = assets.utils

local speed = require(detections.Speed)

local config = require(utils.Config)
local housekeeper = require(utils.Housekeeper)

local playersChecking = {}
local playerData = {}

local function realWait(seconds)
	local total = 0

	repeat
		total = total + services.run.Heartbeat:Wait()
	until total >= seconds
end

local function log(message)
	if not config.logging then return end
	
	print(string.format("[AntiExploit] %s", message))
end

local function punish(player, exploitData)
	local exploitDataString = string.format("Flags: %d, Demerits: %d", exploitData.flags, exploitData.demerits)
	
	if exploitData.demerits >= config.punishments.respawn and exploitData.demerits < config.punishments.kick then
		log(string.format("%s respawned. %s", player.Name, exploitDataString))
		player:LoadCharacter()
	elseif exploitData.demerits >= config.punishments.kick then
		log(string.format("%s kicked. %s", player.Name, exploitDataString))
		player:Kick(string.format("Exploits detected. %s", exploitDataString))
	end
end

local function onHeartbeat()
	for i, player in pairs(playersChecking) do
		local character = player.Character
		local primaryPart = character.PrimaryPart
		local humanoid = character:FindFirstChildOfClass("Humanoid")

		local physicsData = playerData[player].physics
		local exploitData = playerData[player].exploits

		if not primaryPart or whitelist:playerIsWhitelisted(player) then continue end

		exploitData.lastScan = exploitData.lastScan or os.clock()
		local timePassed = os.clock() - exploitData.lastScan

		if humanoid and humanoid.Health <= 0 then
			physicsData.lastPosition = primaryPart.Position

			continue
		end

		if exploitData.lastDetection > 0 then
			if os.clock() - exploitData.lastDetection >= config.flagCooldown then
				physicsData.lastPosition = primaryPart.Position
				exploitData.lastDetection = 0
			else
				continue
			end
		end
		
		if timePassed >= config.runInterval then
			if physicsData.lastPosition then
				for i, moduleScript in pairs(detections:GetChildren()) do
					if config.detections[string.lower(moduleScript.Name)] == false or not character then continue end

					local detection = require(moduleScript)
					local check = detection:run(player, playerData[player], timePassed)

					if check then
						log(string.format("%s was detected [%s] exploiting", player.Name, moduleScript.Name))
						punish(player, exploitData)
					end
				end
			end
			
			physicsData.lastPosition = primaryPart.Position
			exploitData.lastScan = os.clock()	
		end		

	end
end

function antiExploit:run(delayTime)	
	local function onCharacterAdded(player, character)
		local lastPlayerData = playerData[player]
		
		table.insert(playersChecking, player)
		
		playerData[player] = {
			physics = {
				lastPosition = nil,
				maxSpeed = 0,
				maxJump = 0
			},
			exploits = {
				flags = 0,
				detections = {},
				demerits = 0,
				lastScan = os.clock(),
				lastDetection = 0,
			}
		}
		
		local physicsData = playerData[player].physics
		local exploitData = playerData[player].exploits
		
		local humanoid = character.Humanoid
		local primaryPart = character.PrimaryPart
		
		physicsData.maxSpeed = humanoid.WalkSpeed + speed.settings.leeway
		physicsData.maxJump = humanoid.JumpHeight + primaryPart.Size.Y + config.jumpLeeway
		
		if lastPlayerData then 
			playerData[player].exploits = lastPlayerData.exploits
		end
	end
	
	local function onPlayerAdded(player)
		if adminList:playerIsWhitelisted(player) then return end
		
		onCharacterAdded(player, player.Character or player.CharacterAdded:Wait())
		
		local characterAddedEvent = player.CharacterAdded:Connect(function(character)
			onCharacterAdded(player, character)
		end)
		
		housekeeper.dispose(characterAddedEvent)
	end
	
	local function onPlayerRemoving(player)
		housekeeper.cleanup()
		
		playersChecking[player] = nil
		playerData[player] = nil
	end
	
	if delayTime then realWait(delayTime) end
	
	self.running = true
	
	log("Running")
	
	local playerAddedEvent = services.players.PlayerAdded:Connect(onPlayerAdded)
	local playerRemovingEvent = services.players.PlayerRemoving:Connect(onPlayerRemoving)
	
	housekeeper.dispose(playerAddedEvent)
	housekeeper.dispose(playerRemovingEvent)
	
	for i, player in pairs(services.players:GetPlayers()) do
		coroutine.wrap(onPlayerAdded)(player) 
	end
	
	local onHearbeatEvent = services.run.Heartbeat:Connect(onHeartbeat)
	housekeeper.dispose(onHearbeatEvent)
end

function antiExploit:stop(delayTime)
	if delayTime then realWait(delayTime) end
	
	self.running = false
	
	log("Stopped")
	
	housekeeper.cleanup()
	
	for i, player in pairs(playersChecking) do
		local playerPhysicsData = playerData[player].physics
			
		playerPhysicsData.lastPosition = nil
		playerPhysicsData.maxSpeed = 0
		playerPhysicsData.maxJump = 0
		
		playersChecking[player] = nil
	end
end

function antiExploit:exploitData(player)
	return playerData[player].exploits
end

function antiExploit:wipeExploitData(player)
	playerData[player].exploits = {
		flags = 0,
		detections = {},
		demerits = 0,
		lastScan = os.clock(),
		lastDetection = 0,
	}
end

return antiExploit
